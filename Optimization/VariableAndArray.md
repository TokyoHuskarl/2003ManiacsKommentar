MP Version: v.230809  
# 変数操作コマンド負荷メモ  
[未整理の比較例](./unorganized.md)  
  
特記事項がない限り下記の10000000回ループを5回行った平均値による比較とする  
midiの音楽が鳴り始めてから実行。  
<details>
  <summary>Tick measuring event code</summary>
  <div>

  ```tpc
  @sys.gameOpt .picLimit 10000
  @sys.gameOpt .fatal 60, 0, 0
  @bgm.play "2003Empire" .opt 0, 100, 100, 50
  @msg.show "Press any key to start"
  @loop .inf() {
      @wait 0
      v[10] = 5
      v[30] = 10000000
      v[7..8] = 0
      @loop v[10] {
          v[5] = rnd(1, 999999)
          v[6] = rnd(1, 999999)
          @wait 0
          v[5].copy v[1], 2
          v[3] = sys.tick
          @loop v[30] {
              // insert proc a

          }
          v[3] = sys.tick - v[3]
          @wait 0
          v[5].copy v[1], 2
          v[4] = sys.tick
          @loop v[30] {
              // insert proc b

          }

          v[4] = sys.tick - v[4]
          v[7] .add v[3], 2

      }

      v[7..8] /= v[10]
      @msg.show "\> Result:
  \>proc a * 10000000 -> \v[7] tick
  \>proc b * 10000000 -> \v[8] tick"

  }
  ```

  </div>
</details>
  
# 基本
  
## 式解釈はメチャクチャ重い。２行までで抑えられるなら速度が必要な処理に使うべきではない  
- 変数操作をする場合、できるだけ式解釈を使わない書き方（ツクール上の変数操作GUIでオペランド欄が「式」以外になるもの）をしよう。  
基本的に２行までであれば１行で式を使って変数操作するよりも軽い。
例えば  
`v[1] = v[v[114]+v[514]]`のような形で変数番号変数を取りに行きたい場合は、  
```
v[1] = v[114]+v[514]
v[1] = v[v[1]]
```
このように書いた方が早い（後述するが、二行目で配列操作の.derefオペランドを使うとより早いと思われる）  
また、
```
v[1] = v[2] == 111
v[1] = v[2] == 111 ? 1 : 0
```
では2003MP上では同じ結果が得られる(結果は1か0)。  
が、前者は式解釈が挟まってしまう分、三項演算の型が用意されている後者よりも約33%も重い。  
  
- どうしても２行で収まらない計算に関しては開き直って式解釈を使い、１行に収めるとパフォーマンスがよい。  
DIS:Legacy内の実際の処理を例として使う：  
```
Temp19 = max(min(muldiv(agent_MapX, 100, v[430]), v[1277]) - 1, 0)
Temp20 = max(min(muldiv(agent_MapY, 100, v[431]), v[1276]) - 1, 0)
v[v[4563] + Temp19 + Temp20 * v[1277]] = v[335]
```
やっていることの内容はともかく、やたら重くてぐちゃぐちゃして数学関数を呼び出しているような処理が  
三行並んでいることだけ把握して貰えればよい。  
この式を計測ループにかけると、終了までに**2838Tick**という結果が出る。これを  
`v[v[4563] + max(min(muldiv(agent_MapX, 100, v[430]), v[1277]) - 1, 0) + max(min(muldiv(agent_MapY, 100, v[431]), v[1276]) - 1, 0) * v[1277]] = v[335]`  
この一行にまとめると、計測結果はなんと**2021 Tick**となる。  
単純に計算すれば約29%ほど軽くなっているといえ、なかなか効果ありと見てよさそうである。  
**ただし、見ればわかる通り可読性が完全に死んでしまう。**  
ある程度複雑な処理というのはバグの温床となりがちであり、そしてその温床の可読性が悪いと後々必ず酷い目に遭う。  
そのため、まとめる前の処理をコメントアウトで残せるTPCユーザ以外には、ここまですることはあまりおすすめできない。  
  
- まとめとして、とにかく式解釈の呼び出し回数を減らすことを心がけるとよい。  
  また、変数操作のみならず、`@if`コマンドの条件式中でも`を前置して呼び出す式解釈について同様の議論が妥当する。  
  ~~まあ何をどうしても可読性は死んでしまうのだが~~  
  
##  
  
# 配列操作コマンドについて
## 結論
- 複数の変数に対して一気に処理を行う場合は、絶対に配列操作コマンドを使った方がよい。
- 変数同士１対１の単純な四則演算をするときも、基本的に配列操作コマンドを使う方がよい。  
  

## 複数変数に対する処理
- 重かったため、複数変数に対するテストの繰り返し回数は100000回(つまり*10^-2)に変更。
- 当然だが配列操作の方が全然早い。代入のみテスト  
  処理内容自体は違うが、どれくらい早いかの例として載せる。  
  v[2000]以降には0が入っているものとする（複数の変数の初期化処理と考えよ）
`v[2000].copy v[100],1000` -> 8 tick  
`v[100..1099] = 0` -> 395 tick  
これはひどい  
  
### repeat(定数一括代入操作)  
- MP v.231013で~筆者のおねだりによって~追加された新規操作。  
#### 変数を一括代入  
`v[100..1099] = v[10]` -> 404 tick  
`v[100].repeat v[10], 1000` -> 8 tick  
はい。  
#### 定数の一括代入
`v[100..1099] = 0` -> 404 tick  
`v[2000].copy v[100],1000` -> 7 tick  
`v[100].repeat 0, 1000` -> 8 tick  
- 変数操作については結局やっていることが大して変わらないため同じような結果である。  
  もっとも、.repeatと.copyの間の差はいかなるものか。繰り返し数を増やして再計測する。
##### 10000000回繰り返しによる再計測
`v[2000].copy v[100],1000` -> 794 tick  
`v[100].repeat 0, 1000` -> 920 tick  
- 配列コピーの牙城は崩れない。大量の変数の初期化については.copyを用いて未使用の領域から取ってくるほうが高速になるだろう。  
もっとも、1000個の変数に対する操作を10000000回繰り返した結果やっと差異が出るという程度のものであることに鑑みて、  
今後0以外の数字を一括で一気に代入してしまいたい場合は.repeatで妥協してよいと思われる。  
  
## 単体比較
**原則**5回v[1],v[2]に1~999999の乱数を入れた上で繰り返し処理をまわして平均値で比較  
### 代入  
`v[1].copy v[2],1` -> 285 tick  
`v[2] = v[1]` -> 312 tick  
- 少しだけ配列操作の方が早い。  
### 加算
`v[1].add v[2],1` -> 294 tick  
`v[1] += v[2]` -> 574 tick  
- 負荷が約半分。  
### 減算
`v[1].sub v[2],1` -> 295 tick  
`v[1] -= v[2]` -> 581 tick  
- 加算に大体同じ。  
### 乗算
`v[1].mul v[2],1` -> 294 tick  
`v[1] *= v[2]` -> 578 tick  
- よりはやい。  
### 除算
`v[1].mul v[2],1` -> 295 tick  
`v[1] /= v[2]` -> 342 tick  
- これはあまり変わらない~~が、繰り返しているうちに結果が0になるためか~~。 -> 次段落参照  
### 剰余
`v[1].mod v[2],1` -> 297 tick  
`v[1] %= v[2]` -> 592 tick  
- 乗算等と大体同じくらい。
### bit shift Left
- v[2]には1が入っているものとする。
`v[1].shl v[2],1` -> 292 tick  
`v[1] <<= v[2]` -> 310 tick  
- 大して変わらず。  
### bit shift Right
- v[2]には1が入っているものとする。
`v[1].shr v[2],1` -> 290 tick  
`v[1] >>= v[2]` -> 313 tick  
- 大して変わらず。  
### AND
`v[1].and v[2],1` -> 300 tick  
`v[1] &= v[2]` -> 308 tick  
- ほぼ変わらず。  
### OR
`v[1].or v[2],1` -> 291 tick  
`v[1] |= v[2]` -> 311 tick  
- 大して変わらず。
  まにぱで追加されたビット演算についてはほぼ変わらないと見てよいかもしれない。  
### 参照外し  
- 参照外し処理のみクラッシュや不正な結果の出現等を防ぐため、乱数の範囲を11-99に絞っている。
`v[1].deref v[2],1` -> 283 tick  
`v[2] = v[v[1]]` -> 334 tick  
- やはり少し早い。  
#### 参照外しとコピー  
`v[1].deref v[2],1` ->  282tick  
`v[v[1]].copy v[2],1` ->  295tick  
- ほんの僅かだけderefオペランドの方が早い。  
  要素数が1の場合はderefにするとよいと思われるが、手動だとつい間違えがちなので単発参照外し用メタ関数を用意すると良いだろう。  
  
## 数値を毎回再代入
**原則**5回v[1],v[2]に1~999999の乱数を入れた上で繰り返し処理をまわして平均値で比較  
加えて、**v[1],v[2]へ上記乱数を再代入する処理**`v[5].copy v[1],2`**を挟む**
### 加算
`v[1].add v[2],1` -> 533 tick  
`v[1] += v[2]` -> 830 tick  
### 除算
`v[1].div v[2],1` -> 416 tick  
`v[1] /= v[2]` -> 464 tick  
- 別に0になるからではなかった。性能的に除算だけ大して変わらない?
### その他、大して変わらなかったため割愛
  
## まとめ
複数の変数を操作する場合、配列操作で済ませられるなら絶対に配列操作を使おう。  
単純な計算も配列操作を使うと少し早くなりうるが、常に可読性と相談しよう。  
  
# ビット演算
2003MPにおいて、ビット演算は同じ内容の乗算・除算よりも有意に高速である。  
var * 2よりもvar << 1の方が早いし、var / 2 よりもvar >> 1の方が早い。  
2の乗数の掛け算割り算は、可読性担保のため元の処理をコメントアウトした上でシフトを絡めるようにすることをおすすめする。  
（**ただし符号に注意せよ、負の数値を右にシフトしてしまうと大変なことになる**）。  
  
### フラグチェックとビット操作周りについて  
- 三項演算と式を使ったビット演算
変数varとAgentBitsがあり、(var == 114514)が真であれば、AgentBitsにb100を立てる処理を作るとする。  
この際、感覚的には  
A:`AgentBits |= (var == 114514) << 2`  
B:`AgentBits |= var == 114514 ? 4 : 0`  
この両者を比較するとAの方が早いようにも思える。  
しかし、再三繰り返す事柄だが、**2003MPの式解釈は重く、使わない形で一行に収められる場合はそちらで書いたほうが良い**。  
 そのため、この比較においては、式解釈を行わない**B**の方が高速となる。  
  
  
- 例外  
しかしながら、**ビット演算を条件式の要素として用いる場合は少し話が異なる**。  
今度はvarのbit6が真であれば、AgentBitsにb100を立てる処理を作るとする。  
そうすると今度は  
A:`AgentBits |= var & 32 ? 4 : 0`  
B:`AgentBits |= (var & 32) >> 3`  
この両者を比較することになる。ここで前述の事項を踏まえれば、記法Aの方が高速であるとみるのが妥当であるようにも思われる。  
 しかし、**2003MPではANDを三項演算の条件式として利用する場合、式解釈が行われる**。  
そのため、この場合は両者ともに式解釈が介在することになる。  
そうなると前述の議論とは打って変わって、ビット演算のみで計算を終えている式Bのほうが高速となる。  
 **式解釈が重い**ことが負荷の原因であることに鑑みれば、当然のことであるように思われるが、実際にTPCで処理を書いていると見落としがちになる。  
  
ここまで些末な事柄を気にしないといけない場合というのは、現実にはかなり少ないとは思われる……  
とはいえ、速度を出したい場合気にしても損はない。~~可読性が終わること以外は~~  
  
# その他
## 変数計算におけるツクールスイッチの扱い




