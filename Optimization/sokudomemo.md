# 変数操作コマンド負荷メモ  
  
特記事項がない限り下記の10000000回ループを5回行った平均値による比較とする  
midiの音楽が鳴り始めてから実行。  
<details>
  <summary>Tick measuring event code</summary>
  <div>

  ```tpc
  @sys.gameOpt .picLimit 10000
  @sys.gameOpt .fatal 60, 0, 0
  @bgm.play "2003Empire" .opt 0, 100, 100, 50
  @msg.show "Press any key to start"
  @loop .inf() {
      @wait 0
      v[10] = 5
      v[30] = 10000000
      v[7..8] = 0
      @loop v[10] {
          v[5] = rnd(1, 999999)
          v[6] = rnd(1, 999999)
          @wait 0
          v[5].copy v[1], 2
          v[3] = sys.tick
          @loop v[30] {
              // insert proc a

          }
          v[3] = sys.tick - v[3]
          @wait 0
          v[5].copy v[1], 2
          v[4] = sys.tick
          @loop v[30] {
              // insert proc b

          }

          v[4] = sys.tick - v[4]
          v[7] .add v[3], 2

      }

      v[7..8] /= v[10]
      @msg.show "\> Result:
  \>proc a * 10000000 -> \v[7] tick
  \>proc b * 10000000 -> \v[8] tick"

  }
  ```

  </div>
</details>
  
# 基本
  
## 式解釈はメチャクチャ重い。２行までで抑えられるなら速度が必要な処理に使うべきではない  
変数操作をする場合、できるだけ式解釈を使わない書き方（ツクール上の変数操作GUIでオペランド欄が「式」以外になるもの）をしよう。  
基本的に２行までであれば１行で式を使って変数操作するよりも軽い。
例えば  
`v[1] = v[v[114]+v[514]]`のような形で変数番号変数を取りに行きたい場合は、  
```
v[1] = v[114]+v[514]
v[1] = v[v[1]]
```
このように書いた方が早い（後述するが、二行目で配列操作の.derefオペランドを使うとより早いと思われる）  
また、
```
v[1] = v[2] == 111
v[1] = v[2] == 111 ? 1 : 0
```
では2003MP上では同じ結果が得られる(結果は1か0)。  
が、前者は式解釈が挟まってしまう分、三項演算の型が用意されている後者よりも約33%も重い。  
どうしても２行で収まらない計算に関しては開き直って式解釈を使い、１行に収めるとパフォーマンスがよい。  
~~まあそういうことをしていると可読性は死んでしまうが~~  
  
##  
  
# 配列操作コマンドについて
## 短く
変数同士の単純な四則演算ができるときは、基本的に配列操作コマンドを使う方がよい...かもしれない？  
  

## 複数変数に対する処理
- 当然だが配列操作の方が全然早い。代入のみテスト  
  処理内容自体は違うが、どれくらい早いかの例として載せる。  
  v[2000]以降には0が入っているものとする（複数の変数の初期化処理と考えよ）
  重かったので繰り返し回数は100000回に変更。
`v[2000].copy v[100],1000` -> 8 tick  
`v[100..1099] = 0` -> 395 tick  
これはひどい  
  
## 単体比較
**原則**5回v[1],v[2]に1~999999の乱数を入れた上で繰り返し処理をまわして平均値で比較  
### 代入  
`v[1].copy v[2],1` -> 285 tick  
`v[2] = v[1]` -> 312 tick  
- 少しだけ配列操作の方が早い。  
### 加算
`v[1].add v[2],1` -> 294 tick  
`v[1] += v[2]` -> 574 tick  
- 負荷が約半分。  
### 減算
`v[1].sub v[2],1` -> 295 tick  
`v[1] -= v[2]` -> 581 tick  
- 加算に大体同じ。  
### 乗算
`v[1].mul v[2],1` -> 294 tick  
`v[1] *= v[2]` -> 578 tick  
- よりはやい。  
### 除算
`v[1].mul v[2],1` -> 295 tick  
`v[1] /= v[2]` -> 342 tick  
- これはあまり変わらない~~が、繰り返しているうちに結果が0になるためか~~。 -> 次段落参照  
### 剰余
`v[1].mod v[2],1` -> 297 tick  
`v[1] %= v[2]` -> 592 tick  
- 乗算等と大体同じくらい。
### bit shift Left
- v[2]には1が入っているものとする。
`v[1].shl v[2],1` -> 292 tick  
`v[1] <<= v[2]` -> 310 tick  
- 大して変わらず。  
### bit shift Right
- v[2]には1が入っているものとする。
`v[1].shr v[2],1` -> 290 tick  
`v[1] >>= v[2]` -> 313 tick  
- 大して変わらず。  
### AND
`v[1].and v[2],1` -> 300 tick  
`v[1] &= v[2]` -> 308 tick  
- ほぼ変わらず。  
### OR
`v[1].or v[2],1` -> 291 tick  
`v[1] |= v[2]` -> 311 tick  
- 大して変わらず。
  まにぱで追加されたビット演算についてはほぼ変わらないと見てよいかもしれない。  
### 参照外し  
- この処理のみクラッシュや不正な結果の出現等を防ぐため、乱数の範囲を11-99に絞っている。
`v[1].deref v[2],1` -> 283 tick  
`v[2] = v[v[1]]` -> 334 tick  
- やはり少し早い。  
  
## 数値を毎回再代入
**原則**5回v[1],v[2]に1~999999の乱数を入れた上で繰り返し処理をまわして平均値で比較  
加えて、**v[1],v[2]へ上記乱数を再代入する処理**`v[5].copy v[1],2`**を挟む**
### 加算
`v[1].add v[2],1` -> 533 tick  
`v[1] += v[2]` -> 830 tick  
### 除算
`v[1].div v[2],1` -> 416 tick  
`v[1] /= v[2]` -> 464 tick  
- 別に0になるからではなかった。性能的に除算だけ大して変わらない?
### その他、大して変わらなかったため割愛
  
## まとめ
複数の変数を操作する場合、配列操作で済ませられるなら絶対に配列操作を使おう。  
単純な計算も配列操作を使うと少し早くなりうるが、常に可読性と相談しよう。  
  
## ビット演算
2003MPにおいて、ビット演算は同じ内容の乗算・除算よりも有意に高速である。  
var * 2よりもvar << 1の方が早いし、var / 2 よりもvar >> 1の方が早い。  
2の乗数の掛け算割り算は、可読性担保のため元の処理をコメントアウトした上でシフトを絡めるようにすることをおすすめする。  
（**ただし符号に注意せよ、負の数値を右にシフトしてしまうと大変なことになる**）。  
  
### フラグチェックとビット操作周りについて  
- 三項演算と式を使ったビット演算
変数varとAgentBitsがあり、(var == 114514)が真であれば、AgentBitsにb100を立てる処理を作るとする。  
この際、感覚的には  
A:`AgentBits |= (var == 114514) << 2`  
B:`AgentBits |= var == 114514 ? 4 : 0`  
この両者を比較するとAの方が早いようにも思える。  
しかし、再三繰り返す事柄だが、**2003MPの式解釈は重く、使わない形で一行に収められる場合はそちらで書いたほうが良い**。  
 そのため、この比較においては、式解釈を行わない計算が行える**B**の方が高速となる。  
  
  
- 例外  
しかしながら、**ビット演算を条件式の要素として用いる場合は少し話が異なる**。  
今度はvarのbit6が真であれば、AgentBitsにb100を立てる処理を作るとする。  
そうすると今度は  
A:`AgentBits |= var & 32 ? 4 : 0`  
B:`AgentBits |= (var & 32) >> 3`  
この両者を比較することになる。ここで前述の事項を踏まえれば、記法Aの方が高速であるとみるのが妥当であるようにも思われる。  
 しかし、**2003MPではANDを三項演算の条件式として利用する場合、式解釈が行われる**。  
そのため、この場合は両者ともに式解釈が介在することになる。  
そうなると前述の議論とは打って変わって、ビット演算のみで計算を終えている式Bのほうが高速となる。  
 **式解釈が重い**ことが負荷の原因であることに鑑みれば、当然のことであるように思われるが、実際にTPCで処理を書いていると見落としがちになる。  
  
このような些末な事柄を気にしないといけない場合というのは、現実にはかなり少ないとは思われるが、  
しかし、速度を出したい場合気にして損はない。~~可読性が終わること以外は~~  
  
## その他
### 変数計算におけるツクールスイッチの扱い




