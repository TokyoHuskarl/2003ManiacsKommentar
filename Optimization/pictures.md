# ピクチャ関連処理  
前提として、変数操作の章と比較して**計測にあたっての繰り返し回数を減らしている**  
以下、結果の単位に"tick10^-n"というような記載がされていたらば、それは繰り返し回数を10000000からn桁減らして計測したものだと考えてほしい。  
たぶん誤差はあるし記法も不自然だったりするだろう。が、筆者は純文系なので許してほしい。  
  
# ピクチャ表示のバニラからの仕様変更  
## ピクチャキャッシュシステム
- 効果については後述する。  
## bmp拡張子よりもpng拡張子の方が読み込みの負荷が低い（！）  
- いにしえの2000/2003ユーザの間では、bmpにしたほうが読み込みの速度が早いというのが通説であったように思われる。  
  筆者もツールを使ってピクチャディレクトリ内の画像をすべてbmpに変えたりしていた。  
  しかし、この前提はMPにおいては当てはまらず、bmp化はむしろ有害である。計測値については後述する。  
- これは不具合の可能性があるというようなことを以前開発者様が仰っていたため、今後bmpのほうが高速に戻るかもしれない。
  しかしながら、v.230809現在もpngの方が早いし、何よりキャッシュシステムのおかげで現実には対してパフォーマンスに影響しないと思われる。  
  そのため、細かいことは気にせずとりあえずpngにしておけばよいだろう。  
## フルカラーpngが読み込める
- 読めるようになってはいるが、他の画像形式と比較して読み込みが重い。
- また、フルカラービットマップは壊れる。
  
## ピクチャキャッシュシステムの有無による負荷の差  
### 結論  
キャッシュとしてどこか空いたピクチャ番号に画像をロードしておくと表示処理の負荷がメチャクチャマシになる。  
が、キャッシュされていたとして、ピクチャ移動と同じくらい軽いというわけではない。  
### 計測  
```
@pic[2].show {
    "minimapback"
    .pos v[1282], v[1283] .topLeft
    .chromakey 1
    .scale 100
    .trans 0
    .rgbs 100, 100, 100, 100
    .mapLayer 9
    .eraseWhenTransfer
}
@pic[2].erase
```
上記処理を繰り返す。minimapbackはこのディレクトリに同梱されているものと同じ、透明色1色だけで塗りつぶした148x92の画像ファイルである:    
![三種類同梱されているが、見た目は変わらないので以後は表示を省略する](./img/minimapback.bmp)
    
### 結果  
A:どこにも同じ画像がキャッシュされていない状態での試行
- -> 2877 tick10^-2  
B:事前に"ui\minimapback"をpic[1]にロードした状態での試行
- -> **100 tick10^-2**  
  
比較すれば激烈に軽い。沢山消したり出したりする画像はどこかにキャッシュしておこう。  
  
## bmpとpngの読み込み速度の違い  
今度はminimapback.bmpをminimapback.pngに変えて同じ処理を比較する。  
その他の処理内容はピクチャキャッシュシステム〜云々のA,Bと全く同じ。
A ->  
- 2121 tick10^-2  
B ->  
- 105 tick10^-2  
キャッシュ後のBについては誤差の範囲内と思われる。  
が、キャッシュされていない状態の読み込み速度についてはbmp時よりも早いことがわかる。  
  
## フルカラーpng  
フルカラーpng画像であるminimapbackfl.pngに変えて同じ処理を比較する。  
その他の処理内容はピクチャキャッシュシステム〜云々のA,Bと全く同じ。  
A ->  
- 3410 tick10^-2  
B ->  
- 102 tick10^-2  
比較すると非常に重いことがわかるが、キャッシュしてしまえば問題ない。  
キャッシュシステムを作る気がない場合やロード時間を気にする場合は8ビットに収めておくとよいかもしれない。  


  
## ピクチャ編集  
おもいかと思ったら意外と重くない？  
  
### ミニマップ用途について
```
@pic[1].show {
    "minimapback"
    .pos v[1282], v[1283] .topLeft
    .chromakey 1
    .scale 100
    .trans 0
    .rgbs 100, 100, 100, 100
    .mapLayer 9
    .eraseWhenTransfer
}
v[748949].enum 222, 13616
```
上記をループ外に前置して試行

A:
```
@pic[2].show {
    "minimapback"
    .pos v[1282], v[1283] .topLeft
    .chromakey 1
    .scale 100
    .trans 0
    .rgbs 100, 100, 100, 100
    .mapLayer 9
    .eraseWhenTransfer
}
@pic[2].setPixel .xywh 0, 0, 148, 92 .src v[748949]
```
 -> 3830t  
B:  
```  
@loop 16 {
    @pic[2].setPixel .xywh 0, 0, 4, 4 .src v[748949]
    
}


```  
-> 763t  
B2:`@loop 64(略)` -> 2894t  
可能であれば更新する場所のIDを配列として整理してからその配列に対して@foreachをかけて処理した方が早いかもしれない。 

```
@pic[2].show {
    "minimapback"
    .pos v[1282], v[1283] .topLeft
    .chromakey 1
    .scale 100
    .trans 0
    .rgbs 100, 100, 100, 100
    .mapLayer 9
    .eraseWhenTransfer
}
@pic[2].setPixel .xywh 0, 0, 1, 1 .src v[748949]
```
キャッシュから画像を再表示して初期化->2614t  
```
@pic[2].setPixel .xywh 0, 0, 148, 92 .src v[748949]
@pic[2].setPixel .xywh 0, 0, 1, 1 .src v[748949]
```
画像編集による初期化->1239t  
