# 2003MPコマンド負荷メモ  
  
特記事項がない限り下記の10000000回ループを5回行った平均値による比較とする  
midiの音楽が鳴り始めてから実行。  
```tpc
@sys.gameOpt .picLimit 10000
@sys.gameOpt .fatal 60, 0, 0
@bgm.play "2003Empire" .opt 0, 100, 100, 50
@msg.show "That's lnf key to start"
@loop .inf() {
    @wait 0
    v[10] = 5
		v[30] = 10000000
    v[7..8] = 0
    @loop v[10] {
        v[5] = rnd(1, 999999)
        v[6] = rnd(1, 999999)
        @wait 0
        v[5].copy v[1], 2
        v[3] = sys.tick
        @loop v[30] {
            // insert proc a
            
        }
        
        v[3] = sys.tick - v[3]
        @wait 0
        v[5].copy v[1], 2
        v[4] = sys.tick
        @loop v[30] {
            // insert proc b
            
        }
        
        v[4] = sys.tick - v[4]
        v[7] .add v[3], 2
        
    }
    
    v[7..8] /= v[10]
    @msg.show "\> Result:
\>proc a * 10000000 -> \v[7] tick
\>proc b * 10000000 -> \v[8] tick"
    
}
```
# 基本
## 式解釈はメチャクチャ重い。二行までで抑えられるなら使うべきではない  
変数操作をする場合、できるだけ式解釈にならない書き方（ツクール上の変数操作GUIでオペランド欄が「式」以外になるもの）をしよう。  
例えば  
`v[1] = v[v[114]+v[514]]`のような形で変数番号変数を取りに行きたい場合は、  
```
v[1] = v[114]+v[514]
v[1] = v[v[1]]
```
このように書いた方がいい（後述するが、二行目で配列操作の.derefオペランドを使うとより早いと思われる）  
また、
```
v[1] = v[2] == 111
v[1] = v[2] == 111 ? 1 : 0
```
では2003MP上では同じ結果が得られる(1か0)が、前者で式解釈が挟まってしまう分、後者よりも約33%も重い。

  
# 配列操作コマンドについて
変数同士の単純な四則演算ができるときは、基本的に配列操作コマンドを使う方がよい...かもしれない？  
  

## 複数変数に対する処理
- 当然だが配列操作の方が全然早い。代入のみテスト  
  処理内容自体は違うが、どれくらい早いかの例として載せる。  
  v[2000]以降には0が入っているものとする（複数の変数の初期化処理と考えよ）
  重かったので繰り返し回数は100000回に変更。
`v[2000].copy v[100],1000` -> 8 tick  
`v[100..1099] = 0` -> 395 tick  
これはひどい  
  
## 単体比較
**原則**5回v[1],v[2]に1~999999の乱数を入れた上で繰り返し処理をまわして平均値で比較  
### 代入  
`v[1].copy v[2],1` -> 285 tick  
`v[2] = v[1]` -> 312 tick  
- 少しだけ配列操作の方が早い。  
### 加算
`v[1].add v[2],1` -> 294 tick  
`v[1] += v[2]` -> 574 tick  
- 負荷が約半分。  
### 減算
`v[1].sub v[2],1` -> 295 tick  
`v[1] -= v[2]` -> 581 tick  
- 加算に大体同じ。  
### 乗算
`v[1].mul v[2],1` -> 294 tick  
`v[1] *= v[2]` -> 578 tick  
- よりはやい。  
### 除算
`v[1].mul v[2],1` -> 295 tick  
`v[1] /= v[2]` -> 342 tick  
- これはあまり変わらない~~が、繰り返しているうちに結果が0になるためか~~。 -> 次段落参照  
### 剰余
`v[1].mod v[2],1` -> 297 tick  
`v[1] %= v[2]` -> 592 tick  
- 乗算等と大体同じくらい。
### bit shift Left
- v[2]には1が入っているものとする。
`v[1].shl v[2],1` -> 292 tick  
`v[1] <<= v[2]` -> 310 tick  
- 大して変わらず。  
### bit shift Right
- v[2]には1が入っているものとする。
`v[1].shr v[2],1` -> 290 tick  
`v[1] >>= v[2]` -> 313 tick  
- 大して変わらず。  
### AND
`v[1].and v[2],1` -> 300 tick  
`v[1] &= v[2]` -> 308 tick  
- ほぼ変わらず。  
### OR
`v[1].or v[2],1` -> 291 tick  
`v[1] |= v[2]` -> 311 tick  
- 大して変わらず。
  まにぱで追加されたビット演算についてはほぼ変わらないと見てよいかもしれない。  
### 参照外し  
- この処理のみクラッシュや不正な結果の出現等を防ぐため、乱数の範囲を11-99に絞っている。
`v[1].deref v[2],1` -> 283 tick  
`v[2] = v[v[1]]` -> 334 tick  
- やはり少し早い。  
  
## 数値を毎回再代入
**原則**5回v[1],v[2]に1~999999の乱数を入れた上で繰り返し処理をまわして平均値で比較  
加えて、**v[1],v[2]へ上記乱数を再代入する処理**`v[5].copy v[1],2`**を挟む**
### 加算
`v[1].add v[2],1` -> 533 tick  
`v[1] += v[2]` -> 830 tick  
### 除算
`v[1].div v[2],1` -> 416 tick  
`v[1] /= v[2]` -> 464 tick  
- 別に0になるからではなかった。性能的に除算だけ大して変わらない?
### その他、大して変わらなかったため割愛
  
## まとめ？
単純な計算は配列操作を使おう
  
# ビット演算
式中においてはvar * 2よりもvar << 1 の方がちょっと早い。  
2の乗数の掛け算割り算は（ただし符号には注意）。  
でも式解釈を含まない単体の三項演算にできるときはそうした方がよい
v[1] / 2 より v[1] >> 1 のがほんのり早い




